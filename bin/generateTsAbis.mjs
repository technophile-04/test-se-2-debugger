import * as fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

function getDirectories(path) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources, contractName) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);
        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}

function getInheritedFunctions(rootDir, sources, contractName) {
  const ARTIFACTS_DIR = path.join(rootDir, "artifacts");
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {};

  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      const { abi } = JSON.parse(
        fs.readFileSync(path.join(ARTIFACTS_DIR, sourcePath, `${sourceName}.json`)).toString(),
      );
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }

  return inheritedFunctions;
}

function getContractDataFromDeployments(rootDir) {
  const DEPLOYMENTS_DIR = path.join(rootDir, "deployments");
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }
  const output = {};
  for (const chainName of getDirectories(DEPLOYMENTS_DIR)) {
    const chainId = fs.readFileSync(path.join(DEPLOYMENTS_DIR, chainName, ".chainId")).toString();
    const contracts = {};
    for (const contractName of getContractNames(path.join(DEPLOYMENTS_DIR, chainName))) {
      const { abi, address, metadata } = JSON.parse(
        fs.readFileSync(path.join(DEPLOYMENTS_DIR, chainName, `${contractName}.json`)).toString(),
      );
      const inheritedFunctions = getInheritedFunctions(rootDir, JSON.parse(metadata).sources, contractName);
      contracts[contractName] = { address, abi, inheritedFunctions };
    }
    output[chainId] = contracts;
  }
  return output;
}

export async function generateTsAbis(rootDir) {
  const TARGET_DIR = path.join(__dirname, "..", "contracts");
  const allContractsData = getContractDataFromDeployments(rootDir);

  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  const tsContent = `${generatedContractComment}
import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

const deployedContracts = {${fileContent}} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  fs.writeFileSync(path.join(TARGET_DIR, "deployedContracts.ts"), tsContent);

  console.log(`üìù Updated TypeScript contract definition file on ${path.join(TARGET_DIR, "deployedContracts.ts")}`);
}
